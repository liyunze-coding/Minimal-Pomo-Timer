"use strict";var Streamerbot=(()=>{var W=Object.create;var p=Object.defineProperty;var L=Object.getOwnPropertyDescriptor;var H=Object.getOwnPropertyNames;var U=Object.getPrototypeOf,D=Object.prototype.hasOwnProperty;var q=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),M=(n,e)=>{for(var t in e)p(n,t,{get:e[t],enumerable:!0})},w=(n,e,t,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of H(e))!D.call(n,r)&&r!==t&&p(n,r,{get:()=>e[r],enumerable:!(o=L(e,r))||o.enumerable});return n};var O=(n,e,t)=>(t=n!=null?W(U(n)):{},w(e||!n||!n.__esModule?p(t,"default",{value:n,enumerable:!0}):t,n)),B=n=>w(p({},"__esModule",{value:!0}),n);var G=q((Q,P)=>{"use strict";P.exports=function(){throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object")}});var I={};M(I,{Client:()=>h});var g=class{constructor(e={}){this.logLevels={verbose:0,debug:1,info:2,warn:3,error:4,none:5};this.level=e.level||"info",this.customLogger=e.customLogger}setLevel(e){this.level=e}setCustomLogger(e){this.customLogger=e}verbose(...e){this.log("verbose",...e)}debug(...e){this.log("debug",...e)}info(...e){this.log("info",...e)}warn(...e){this.log("warn",...e)}error(...e){this.log("error",...e)}log(e,...t){if(!(this.logLevels[e]<this.logLevels[this.level]))if(this.customLogger)this.customLogger(e,...t);else switch(e){default:case"verbose":console.log(...t);break;case"debug":console.debug(...t);break;case"info":console.info(...t);break;case"warn":console.warn(...t);break;case"error":console.error(...t);break}}},y=new g;var l={General:["Custom"],Twitch:["Follow","Cheer","Sub","ReSub","GiftSub","GiftBomb","Raid","HypeTrainStart","HypeTrainUpdate","HypeTrainLevelUp","HypeTrainEnd","RewardRedemption","RewardCreated","RewardUpdated","RewardDeleted","CommunityGoalContribution","CommunityGoalEnded","StreamUpdate","Whisper","FirstWord","SubCounterRollover","BroadcastUpdate","StreamUpdateGameOnConnect","PresentViewers","PollCreated","PollUpdated","PollCompleted","PredictionCreated","PredictionUpdated","PredictionCompleted","PredictionCanceled","PredictionLocked","ChatMessage","ChatMessageDeleted","UserTimedOut","UserBanned","Announcement","AdRun","BotWhisper","CharityDonation","CharityCompleted","CoinCheer","ShoutoutCreated","UserUntimedOut","CharityStarted","CharityProgress","GoalBegin","GoalProgress","GoalEnd","ShieldModeBegin","ShieldModeEnd","AdMidRoll","StreamOnline","StreamOffline","ShoutoutReceived","ChatCleared","RaidStart","RaidSend","RaidCancelled","PollTerminated","PyramidSuccess","PyramidBroken","ViewerCountUpdate","GuestStarSessionBegin","GuestStarSessionEnd","GuestStarGuestUpdate","GuestStarSlotUpdate","GuestStarSettingsUpdate","HypeChat","RewardRedemptionUpdated","HypeChatLevel","BroadcasterAuthenticated","BroadcasterChatConnected","BroadcasterChatDisconnected","BroadcasterPubSubConnected","BroadcasterPubSubDisconnected","BroadcasterEventSubConnected","BroadcasterEventSubDisconnected","SevenTVEmoteAdded","SevenTVEmoteRemoved","BetterTTVEmoteAdded","BetterTTVEmoteRemoved","BotChatConnected","BotChatDisconnected","UpcomingAd","ModeratorAdded","ModeratorRemoved","VipAdded","VipRemoved","UserUnbanned","UnbanRequestApproved","UnbanRequestDenied","AutomaticRewardRedemption","UnbanRequestCreated","ChatEmoteModeOn","ChatEmoteModeOff","ChatFollowerModeOn","ChatFollowerModeOff","ChatFollowerModeChanged","ChatSlowModeOn","ChatSlowModeOff","ChatSlowModeChanged","ChatSubscriberModeOn","ChatSubscriberModeOff","ChatUniqueModeOn","ChatUniqueModeOff","AutoModMessageHeld","AutoModMessageUpdate","BlockedTermsAdded","BlockedTermsDeleted","WarnedUser","SuspiciousUserUpdate","PermittedTermsAdded","PermittedTermsDeleted","WarningAcknowledged","WatchStreak","PollArchived","SharedChatSessionBegin","SharedChatSessionUpdate","SharedChatSessionEnd","PrimePaidUpgrade","PayItForward","GiftPaidUpgrade","BitsBadgeTier","SharedAnnouncement","SharedRaid","SharedPrimePaidUpgrade","SharedGiftPaidUpgrade","SharedPayItForward","SharedSub","SharedResub","SharedSubGift","SharedCommunitySubGift"],Streamlabs:["Donation","Merchandise","Connected","Disconnected","CharityDonation"],SpeechToText:["Dictation","Command"],Command:["Triggered","Cooldown"],FileWatcher:["Changed","Created","Deleted","Renamed"],FileTail:["Changed"],Quote:["Added","Show"],Misc:["TimedAction","Test","ProcessStarted","ProcessStopped","ChatWindowAction","StreamerbotStarted","StreamerbotExiting","ToastActivation","GlobalVariableUpdated","UserGlobalVariableUpdated","ApplicationImport"],Raw:["Action","SubAction","ActionCompleted"],WebsocketClient:["Open","Close","Message"],StreamElements:["Tip","Merch","Connected","Disconnected","Authenticated"],WebsocketCustomServer:["Open","Close","Message"],DonorDrive:["Donation","ProfileUpdated","Incentive"],YouTube:["BroadcastStarted","BroadcastEnded","Message","MessageDeleted","UserBanned","SuperChat","SuperSticker","NewSponsor","MemberMileStone","NewSponsorOnlyStarted","NewSponsorOnlyEnded","StatisticsUpdated","BroadcastUpdated","MembershipGift","GiftMembershipReceived","FirstWords","PresentViewers","NewSubscriber","BroadcastMonitoringStarted","BroadcastMonitoringEnded","BroadcastAdded","BroadcastRemoved","SevenTVEmoteAdded","SevenTVEmoteRemoved","BetterTTVEmoteAdded","BetterTTVEmoteRemoved"],Pulsoid:["HeartRatePulse"],HypeRate:["HeartRatePulse","TwitchClipCreated","Connected","Disconnected"],Kofi:["Donation","Subscription","Resubscription","ShopOrder","Commission"],Patreon:["FollowCreated","FollowDeleted","PledgeCreated","PledgeUpdated","PledgeDeleted"],Application:["ActionAdded","ActionUpdated","ActionDeleted"],TipeeeStream:["Donation"],TreatStream:["Treat","Authenticated","Connected","Disconnected"],Shopify:["OrderCreated","OrderPaid"],Obs:["Connected","Disconnected","Event","SceneChanged","StreamingStarted","StreamingStopped","RecordingStarted","RecordingStopped","VendorEvent"],Midi:["Message"],HotKey:["Press"],StreamDeck:["Action","Connected","Disconnected","Info"],Custom:["Event","CodeEvent"],VTubeStudio:["ModelLoaded","ModelUnloaded","BackgroundChanged","ModelConfigChanged","HotkeyTriggered","ModelAnimation","Connected","Disconnected","TrackingStatusChanged","ItemEvent","ModelClicked"],CrowdControl:["GameSessionStart","GameSessionEnd","EffectRequest","EffectSuccess","EffectFailure","TimedEffectStarted","TimedEffectEnded","TimedEffectUpdated","CoinExchange"],Elgato:["WaveLinkOutputSwitched","WaveLinkOutputVolumeChanged","WaveLinkOutputMuteChanged","WaveLinkSelectedOutputChanged","WaveLinkInputVolumeChanged","WaveLinkInputMuteChanged","WaveLinkInputNameChanged","WaveLinkMicrophoneGainChanged","WaveLinkMicrophoneOutputVolumeChanged","WaveLinkMicrophoneBalanceChanged","WaveLinkMicrophoneMuteChanged","WaveLinkMicrophoneSettingChanged","WaveLinkFilterAdded","WaveLinkFilterChanged","WaveLinkFilterDeleted","WaveLinkFilterBypassStateChanged","WaveLinkConnected","WaveLinkDisconnected","WaveLinkInputLevelMeterChanged","WaveLinkOutputLevelMeterChanged","CameraHubConnected","CameraHubDisconnected","CameraHubWebcamConnected","CameraHubWebcamrDisconnected","CameraHubWebcamActivated","CameraHubWebcamDeactivated","CameraHubSelectedWebcamChanged","CameraHubWebcamMirrored","CameraHubWebcamFlipped","CameraHubWebcamDeviceOrientationChanged","CameraHubWebcamExposureAutoLockEnabled","CameraHubWebcamExposureAutoLockDisabled","CameraHubWebcamSnapshotTaken","CameraHubWebcamZoomChanged","CameraHubWebcamContrastChanged","CameraHubWebcamWhiteBalanceChanged","CameraHubWebcamAutoExposureEnabled","CameraHubWebcamAutoExposureDisabled","CameraHubWebcamAutoWhiteBalanceEnabled","CameraHubWebcamAutoWhiteBalanceDisabled","CameraHubWebcamNoiseReductionEnabled","CameraHubWebcamNoiseReductionDisabled","CameraHubWebcamISOChanged","CameraHubWebcamShutterSpeedChanged","CameraHubWebcamSharpnessChanged","CameraHubWebcamAntiFlickerChanged","CameraHubWebcamLensChanged","CameraHubWebcamARLensChanged","CameraHubWebcamBitrateChanged","CameraHubWebcamFlashEnabled","CameraHubWebcamFlashDisabled","CameraHubWebcamPanChanged","CameraHubTiltChanged","CameraHubWebcamOverscanChanged","CameraHubWebcamAutoFocusEnabled","CameraHubWebcamAutoFocusDisabled","CameraHubWebcamFocusChanged","CameraHubWebcamWhiteBalanceTintChanged","CameraHubWebcamBrightnessChanged","CameraHubWebcamSaturationChanged","CameraHubWebcamLiveISOChanged","CameraHubWebcamLiveShutterSpeedChanged","CameraHubWebcamLiveWhiteBalanceChanged","CameraHubWebcamLiveWhiteBalanceTintChanged","CameraHubPrompterConnected","CameraHubPrompterDisconnected","CameraHubPrompterModeChanged","CameraHubPrompterBrightnessChanged","CameraHubPrompterFontChanged","CameraHubPrompterFontSizeChanged","CameraHubPrompterAutoScrollEnabled","CameraHubPrompterAutoScrollDisabled","CameraHubPrompterAutoScrollChapterEnabled","CameraHubPrompterAutoScrollChapterDisabled","CameraHubPrompterScrollSpeedChanged","CameraHubPrompterOpacityChanged","CameraHubPrompterHorizontalMarginChanged","CameraHubPrompterVerticalMarginChanged","CameraHubPrompterLineSpacingChanged","CameraHubPrompterFontColorChanged","CameraHubPrompterBackgroundColorChanged","CameraHubPrompterSelectedChapterChanged","CameraHubPrompterChannelsChanged","CameraHubPrompterSelectedChannelChanged","CameraHubPrompterContrastChanged","CameraHubPrompterCrosshairEnabled","CameraHubPrompterCrosshairDisabled","CameraHubPrompterCrosshairImageChanged","CameraHubPrompterCrosshairColorChanged","CameraHubPrompterSelectedScriptChanged"],StreamlabsDesktop:["Connected","Disconnected","SceneChanged","StreamingStarted","StreamingStopped","RecordingStarted","RecordingStopped"],SpeakerBot:["Connected","Disconnected"],Fourthwall:["ProductCreated","ProductUpdated","GiftPurchase","OrderPlaced","OrderUpdated","Donation","SubscriptionPurchased","SubscriptionExpired","SubscriptionChanged","ThankYouSent","NewsletterSubscribed","GiftDrawStarted","GiftDrawEnded"],Trovo:["BroadcasterAuthenticated","BroadcasterChatConnected","BroadcasterChatDisconnected","FirstWords","PresentViewers","ChatMessage","Follow","SpellCast","CustomSpellCast","Raid","Subscription","Resubscription","GiftSubscription","MassGiftSubscription","StreamOnline","StreamOffline"],ThrowingSystem:["Connected","WebsocketConnected","WebsocketDisconnected","EventsConnected","EventsDisconnected","ItemHit","TriggerActivated","TriggerEnded"],Pallygg:["Connected","Disconnected","CampaignTip"],StreamerBotRemote:["InstanceConnected","InstanceDisconnected","InstanceTrigger","InstanceSignal"],VoiceMod:["Connected","Disconnected","VoiceLoaded","SoundboardChanged"],Group:["Added","Removed","Cleared","UsersAdded","UsersRemoved"],MeldStudio:["Connected","Disconnected","StreamingStarted","StreamingStopped","RecordingStarted","RecordingStopped","SceneChanged","LayerVisbilityChanged","LEffectEnabledStateChanged","TrackMonitoringStateChanged","TrackMustedStateChanged","Event"]};var E=globalThis.crypto,R=E.subtle;var T=n=>E.getRandomValues(n);function C(n="req"){return`sb:client:${n}:${Date.now()}-${T(new Uint32Array(12))[0]}`}function k(n){let e;return n.code==1e3?e="Connection closed.":n.code==1001?e='Endpoint is "going away".':n.code==1002?e="Connection closed due to a protocol error.":n.code==1003||n.code==1007||n.code==1008||n.code==1010?e="Bad request.":n.code==1004?e="Reserved":n.code==1005?e="Missing status code.":n.code==1006?e="The connection was closed abnormally.":n.code==1009?e="Message size limit exceeded.":n.code==1011?e="Server terminated connection because due to unexpected condition.":n.code==1015?e="TLS handshake failure":e="Unknown error",e}async function b(n,e){let{timeout:t,message:o="Operation timed out.",controller:r}=e,s;return await Promise.race([new Promise((a,i)=>{s=setTimeout(()=>(r.abort(),console.debug("[withTimeout] timeout reached",e),i(new Error(o))),t),e.signal?.addEventListener("abort",()=>{clearTimeout(s),r?.abort(),i(new Error("Operation aborted."))},{once:!0})}),n]).finally(()=>{clearTimeout(s),r.abort()})}async function S(n){let e=new TextEncoder().encode(n),t=await R.digest("SHA-256",e),r=Array.from(new Uint8Array(t)).map(s=>s.toString(16).padStart(2,"0")).join("");return x(r)}function x(n){let e=new Uint8Array(n.match(/.{1,2}/g).map(o=>parseInt(o,16)));return btoa(String.fromCharCode.apply(null,Array.from(e)))}function f({timeout:n=1e4,addEventListener:e,removeEventListener:t}){let o=C("res"),r=new AbortController,s=r.signal,a=new Promise((i,d)=>{let c=m=>{let v=m?.data;v?.eventName===o&&(r.abort(),i(v?.args))};e("Custom.Event",c);let u=setTimeout(()=>{r.abort(),d(new Error("Timed out waiting for Custom Event"))},n);s.addEventListener("abort",()=>{clearTimeout(u),t(m=>m.events?.includes("Custom.Event")&&m.callback===c)},{once:!0})});return{responseId:o,promise:a,controller:r}}var A={scheme:"ws",host:"127.0.0.1",port:8080,endpoint:"/",immediate:!0,autoReconnect:!0,retries:-1,subscribe:{},logger:y,logLevel:"info"},h=class{constructor(e=A){this._authEnabled=!1;this._authenticated=!1;this.listeners=[];this.subscriptions={};this._explicitlyClosed=!1;this._retried=0;this._connectController=new AbortController;this._reconnectTimeout=void 0;this.options={...A,...e},this.logger=this.options.logger||null,this.logger&&this.options.logLevel&&this.logger.setLevel(this.options.logLevel),this.options.immediate===!0&&this.connect().catch(t=>this.logger?.warn("Failed to connect:",t))}get authenticated(){return!!this.socket&&this.socket.readyState===this.socket.OPEN&&this._authenticated}async connect(e=1e4){if(this.socket?.readyState!==this.socket?.CLOSED)try{await this.disconnect()}catch{}this._explicitlyClosed=!1,this._connectController.abort(),this._connectController=new AbortController;let t=new AbortController;return this._connectController.signal.addEventListener("abort",()=>{t.abort()},{once:!0}),await b(new Promise(async(o,r)=>{try{this.options.password&&(this._authEnabled=!0);let s=`${this.options.scheme}://${this.options.host}:${this.options.port}${this.options.endpoint}`;this.logger?.debug("Connecting to Streamer.bot WebSocket server at",s,this._authEnabled?"with authentication":""),this.socket=globalThis?.process?.versions?.node?new(await Promise.resolve().then(()=>O(G(),1))).WebSocket(s):new WebSocket(s),this.socket.onmessage=this.onMessage.bind(this),this.socket.onopen=this.onOpen.bind(this),this.socket.onclose=this.onClose.bind(this),this.socket.onerror=this.onError.bind(this),this.socket.addEventListener("open",()=>{if(!this.socket)return r(new Error("WebSocket not initialized"));o()},{signal:t.signal}),this.socket.addEventListener("close",()=>r(new Error("WebSocket closed")),{once:!0})}catch(s){try{await this.disconnect(),this?.options?.onError?.(s)}catch(a){this.logger?.warn("Error invoking onError handler",a)}r(s)}}),{timeout:e,message:"WebSocket connection timeout exceeded",controller:t})}async disconnect(e=1e3,t=1e3){if(this._explicitlyClosed=!0,this._connectController.abort(),this._reconnectTimeout&&clearTimeout(this._reconnectTimeout),!this.socket||this.socket.readyState===this.socket.CLOSED)return;let o=new AbortController,r=o.signal;return await b(new Promise((s,a)=>{if(this.socket?.addEventListener("close",()=>{this.logger?.debug("Disconnected from Streamer.bot WebSocket server"),s()},{signal:r}),this.socket?.readyState!==this.socket?.CLOSING)try{this.socket?.close(e)}catch(i){a(i)}}),{timeout:t,message:"Timeout exceeded while closing connection",controller:o})}async handshake(){if(!this.socket)throw new Error("WebSocket not initialized");let e=new AbortController,{signal:t}=e;this._connectController.signal.addEventListener("abort",()=>{e.abort()},{once:!0,signal:t});let o=await b(new Promise((r,s)=>{this.socket?.addEventListener("message",async a=>{if(!("data"in a)||!a.data||typeof a.data!="string"){this.logger?.debug("Unknown message received",a);return}try{let i=JSON.parse(a.data);i&&"info"in i&&r(i)}catch(i){this.logger?.warn("Invalid JSON payload received",a.data),s(i)}},{signal:t})}),{timeout:5e3,message:"Handshake timeout exceeded",controller:e});if(!o||!("info"in o))throw new Error("Handshake failed (invalid payload)");if("request"in o&&o?.request==="Hello"&&o.authentication)return await this.authenticate(o);if(o.info&&!o.authentication){this.logger?.debug("Connected to Streamer.bot WebSocket server",o.info),this.info=o.info,this.version=o.info.version;return}throw new Error("Handshake failed (unknown)")}async authenticate(e){if(!this._authEnabled||!this.options.password){if(this.logger?.debug("No password provided for authentication. Checking if auth is enforced for all requests..."),(await this.getInfo()).status==="ok"){this._authenticated=!1,this.version=e.info.version,this.info=e.info;return}throw await this.disconnect(),new Error("Authentication required")}if(!e.authentication)throw this.logger?.debug("Missing authentication payload"),await this.disconnect(),new Error("Invalid authentication payload");this.logger?.debug("Authenticating with Streamer.bot WebSocket server...");let{salt:t,challenge:o}=e?.authentication,r=await S(`${this.options.password}${t}`),s=await S(`${r}${o}`);if((await this.request({request:"Authenticate",authentication:s})).status==="ok")this._authenticated=!0,this.version=e.info.version,this.info=e.info;else throw await this.disconnect(),new Error("Authentication failed")}async onOpen(){this._retried=0,this._reconnectTimeout&&clearTimeout(this._reconnectTimeout);try{this._authEnabled||this.getInfo().catch(()=>this.logger?.debug("Failed to fetch Streamer.bot instance info")),await this.handshake(),this.version&&this.info&&(this.logger?.debug(`Connected to Streamer.bot: v${this.version} (${this.info.name})`),this?.options?.onConnect?.(this.info))}catch(e){return this.logger?.warn("Failed handshake with Streamer.bot",e),this.options?.onError?.(e instanceof Error?e:new Error("Failed handshake with Streamer.bot")),await this.disconnect()}try{(this.options.subscribe==="*"||Object.keys(this.options.subscribe??{}).length)&&await this.subscribe(this.options.subscribe),Object.keys(this.subscriptions??{}).length&&await this.subscribe(this.subscriptions),this.logger?.debug("Subscribed to requested events",this.subscriptions,this.listeners)}catch(e){this.logger?.warn("Error subscribing to requested events",e)}}onClose(e){this._connectController.abort();try{(e.type==="error"||!e.wasClean)&&this.options.onError&&this?.options?.onError(new Error(k(e))),this?.options?.onDisconnect?.()}catch(t){this.logger?.warn("Error invoking user-provided onDisconnect handler",t)}if(this._explicitlyClosed||!this.options.autoReconnect)return this.logger?.debug("Cleaning up..."),this.cleanup();this._retried+=1,typeof this.options.retries=="number"&&(this.options.retries<0||this._retried<this.options.retries)?(this._reconnectTimeout&&clearTimeout(this._reconnectTimeout),this._reconnectTimeout=setTimeout(async()=>{if(!(this.socket&&this.socket.readyState!==this.socket.CLOSED)){this.logger?.debug(`Reconnecting... (attempt ${this._retried})`);try{await this.connect(1e4)}catch(t){this._retried&&this.logger?.warn(`Failed to reconnect (attempt ${this._retried-1})`,t)}}},Math.min(3e4,this._retried*1e3))):(this.logger?.debug("Auto-reconnect limit reached. Cleaning up..."),this.cleanup())}async onMessage(e){if(!e.data||typeof e.data!="string"){this.logger?.debug("Unknown message received",e);return}let t;try{t=JSON.parse(e.data)}catch(o){this.logger?.warn("Invalid JSON payload received",e.data,o);return}this.logger?.verbose("RECV",t);try{this.options.onData&&this?.options?.onData(t)}catch(o){this.logger?.warn("Error occurred within user-provided onData callback",o)}if(t?.event?.source&&t?.event?.type){for(let o of this.listeners)if(o.events?.length&&o.events.find(r=>r==="*"||r===`${t?.event?.source}.${t?.event?.type}`||r.split(".",2)?.[1]==="*"&&r.split(".",2)?.[0]===t?.event?.source))try{o.callback(t)}catch(r){this.logger?.warn(`Error occurred within user-provided event callback (${o.events})`,r)}}}onError(e){this.logger?.debug("WebSocket onError",e),this.socket&&this.socket.readyState!==this.socket.OPEN&&this._connectController.abort();try{this?.options?.onError?.(new Error("WebSocket Error"))}catch(t){this.logger?.warn("Error occurred within user-provided onError callback",t)}}cleanup(){this.socket&&(this.socket.onopen=null,this.socket.onclose=null,this.socket.onerror=null,this.socket.onmessage=null,this.socket=void 0),this.listeners=[],this._retried=0,this._connectController.abort(),this._reconnectTimeout&&clearTimeout(this._reconnectTimeout)}send(e){this.socket?.send(JSON.stringify(e))}async request(e,t="",o=1e4){if(!this.socket||this.socket.readyState!==this.socket.OPEN)throw new Error("WebSocket is not connected");t||(t=C());let r=new AbortController,s=r.signal;this._connectController.signal.addEventListener("abort",()=>{r.abort()},{once:!0,signal:s});let a=await b(new Promise((i,d)=>{this.socket?.addEventListener("message",c=>{if(!("data"in c)||!c.data||typeof c.data!="string"){this.logger?.debug("Unknown message received",c.data);return}try{let u=JSON.parse(c?.data);if(u?.id===t)return this.logger?.verbose(`RECV :: ${e.request}`,u),i(u)}catch(u){this.logger?.warn("Invalid JSON payload received",c.data),d(u)}},{signal:s}),this.logger?.verbose(`SEND :: ${e.request}`,{...e,id:t}),this.send({...e,id:t})}),{timeout:o,message:"Request timed out",controller:r,signal:s});if(a?.status==="ok"){try{this.options.onData&&this?.options?.onData(a)}catch(i){this.logger?.warn("Error invoking onData handler",i)}return{event:{source:"Request",type:e.request??"Unknown"},...a}}throw new Error("Request failed")}async on(e,t){try{if(!e)return;if(e==="*"){let o=l;for(let r in o){if(r===void 0||!Object.keys(l).includes(r))continue;let s=r,a=o[s]??[];if(a&&a.length){let i=new Set([...this.subscriptions[s]??[],...a]);this.subscriptions[s]=[...i]}}}else{let[o,r]=e.split(".",2);if(!o||!r||!(o in l))return;let s=o,a=r;if(a){let i=new Set([...this.subscriptions[s]??[],...a==="*"?l[s]:[a]]);this.subscriptions[s]=[...i]}else throw new Error("Invalid event type")}this.socket&&this.socket.readyState===this.socket.OPEN&&this.version&&await this.subscribe(this.subscriptions),this.listeners.push({events:[e],callback:t}),this.logger?.debug("Added subscription for",e)}catch(o){this.logger?.warn("Failed adding subscription for",e,o)}}async subscribe(e){e==="*"&&(e=l);for(let t in e){if(t===void 0||!Object.keys(l).includes(t))continue;let o=t,r=e[o]??[];if(r&&r.length){let s=new Set([...this.subscriptions[o]??[],...r]);this.subscriptions[o]=[...s]}}return await this.request({request:"Subscribe",events:this.subscriptions})}async unsubscribe(e){e==="*"&&(e=l);for(let t in e){if(t===void 0||!Object.keys(l).includes(t))continue;let o=t,r=e[o];if(r&&r.length)for(let s of r)s&&this.subscriptions[o]?.filter&&(this.subscriptions[o]=this.subscriptions[o])?.filter(a=>s!==a)}return await this.request({request:"UnSubscribe",events:e})}async getEvents(){return await this.request({request:"GetEvents"})}async getActions(){return await this.request({request:"GetActions"})}async doAction(e,t,o){if(o?.customEventResponse)return this.doActionWithCustomEventResponse(e,t);let r,s;return typeof e=="string"?r=e:(r=e.id,s=e.name),await this.request({request:"DoAction",action:{id:r,name:s},args:t})}async doActionWithCustomEventResponse(e,t={},o=1e4){if(!this.socket||this.socket.readyState!==this.socket.OPEN)throw new Error("WebSocket is not connected");let{responseId:r,promise:s,controller:a}=f({timeout:o,addEventListener:(d,c)=>this.on(d,c),removeEventListener:d=>{this.listeners=this.listeners.filter(c=>!d(c))}}),i={...t,sbClientResponse:r};try{let d=await this.doAction(e,i),c=await s;return{...d,customEventResponseArgs:c}}catch(d){throw a.signal.aborted||a.abort(),d}}async getBroadcaster(){return await this.request({request:"GetBroadcaster"})}async getMonitoredYouTubeBroadcasts(){return await this.request({request:"GetMonitoredYouTubeBroadcasts"})}async getCredits(){return await this.request({request:"GetCredits"})}async testCredits(){return await this.request({request:"TestCredits"})}async clearCredits(){return await this.request({request:"ClearCredits"})}async getInfo(){return await this.request({request:"GetInfo"})}async getActiveViewers(){return await this.request({request:"GetActiveViewers"})}async executeCodeTrigger(e,t,o){return o?.customEventResponse?this.executeCodeTriggerWithCustomEventResponse(e,t):await this.request({request:"ExecuteCodeTrigger",triggerName:e,args:t})}async executeCodeTriggerWithCustomEventResponse(e,t={},o=1e4){if(!this.socket||this.socket.readyState!==this.socket.OPEN)throw new Error("WebSocket is not connected");let{responseId:r,promise:s,controller:a}=f({timeout:o,addEventListener:(d,c)=>this.on(d,c),removeEventListener:d=>{this.listeners=this.listeners.filter(c=>!d(c))}}),i={...t,sbClientResponse:r};try{let d=await this.executeCodeTrigger(e,i),c=await s;return{...d,customEventResponseArgs:c}}catch(d){throw a.signal.aborted||a.abort(),d}}async getCodeTriggers(){return await this.request({request:"GetCodeTriggers"})}async getCommands(){return await this.request({request:"GetCommands"})}async getEmotes(e){switch(e){case"twitch":return await this.request({request:"TwitchGetEmotes"});case"youtube":return await this.request({request:"YouTubeGetEmotes"});default:throw new Error("Invalid platform")}}async getGlobals(e=!0){return await this.request({request:"GetGlobals",persisted:e})}async getGlobal(e,t=!0){let o=await this.request({request:"GetGlobal",variable:e,persisted:t});return o.status==="ok"?o.variables[e]?{id:o.id,status:o.status,variable:o.variables[e]}:{status:"error",error:"Variable not found"}:o}async getUserGlobals(e,t=null,o=!0){let s={twitch:"TwitchGetUserGlobals",youtube:"YouTubeGetUserGlobals",trovo:"TrovoGetUserGlobals"}[e];if(!s)throw new Error("Invalid platform");return await this.request({request:s,variable:t,persisted:o})}async getUserGlobal(e,t,o=null,r=!0){let a={twitch:"TwitchGetUserGlobal",youtube:"YouTubeGetUserGlobal",trovo:"TrovoGetUserGlobal"}[e];if(!a)throw new Error("Invalid platform");let i=await this.request({request:a,userId:t,variable:o||null,persisted:r});if(i.status==="ok"&&t&&o){let d=i.variables.find(c=>c.name===o);return d?{id:i.id,status:i.status,variable:d}:{status:"error",error:"Variable not found"}}return i}async sendMessage(e,t,{bot:o=!1,internal:r=!0,...s}={}){if(!this._authenticated)return{status:"error",error:"Authentication required"};let a={platform:e,message:t,bot:o,internal:r};return e==="twitch"&&s.replyId&&Object.assign(a,{replyId:s.replyId}),e==="youtube"&&s.broadcastId&&Object.assign(a,{broadcastId:s.broadcastId}),await this.request({...a,request:"SendMessage"})}async getUserPronouns(e,t){return await this.request({request:"GetUserPronouns",platform:e,userLogin:t})}};Object.assign(globalThis,{StreamerbotClient:h});return B(I);})();
